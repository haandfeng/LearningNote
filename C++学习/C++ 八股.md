# Select,  Poll, Epoll的区别
select、poll、epoll都是1/0多路复用技术，使得程序能够监听多个文件描述符，能提高程序的性能
## Select
1. ﻿﻿首先往用户区构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中，
2. ﻿﻿通过select（）函数监听列表中的文件描述符，直到这些描述符中的一个或者多个进行1/0操作时，该函数才返回。 
	1. ﻿﻿这个函数是阻塞
	2. ﻿﻿函数对文件描述符的检测的操作是由*内核**完成的（涉及到一个将列表从用户条拷贝到内核态的操作）

3. 返 有多少的文件描述符需要进行/0操作把内核态的文件描述符列表拷贝到用卢这）
4. 主进程遍历文件描述符列表，处理1/0事件

缺点：

1. ﻿﻿每次调用select，都需要把fd集合从用户态拷贝到内核态，再有内核态拷贝到用户态，这个开销在fd很多时会很大
2. ﻿﻿同时每次调用select都需要在内核遍历传递进来的所有fd，再拷贝出来还需要遍历所有pd，这个开销在fd很多时也很大
3. ﻿﻿﻿select支持的文件描述符数量太小了，默认是1024
4. ﻿﻿文件描述符列表不能重用，每次都需要重置

## Poll
相比slect，poll将存储文件描述符的列表换成了动态数组，以链表形式来组织，突破了文件描述符数量的限制。其他的与select一样吧

poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O（n），而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈撸数级增长

## Epoll
1. epoll直接在内核中创建两个数据结构，一个是用来存储待监测文件描述符的红黑树，一个是存储发生1/0事件的就绪列表（双链表）。
2. 通过epoll_ wait（）函数遍历存放所有fd的红黑树，并将发生事件对应的文件描述符fd直接插入到就绪列表中。
3. 主进程直接遍历内核返回的就绪列表，处理1/0事件
epoll有两种事件处方方式：水平触发LT与边沿触发ET
### LT
假设委托内核检测读事件 -> 检测fd的读缓冲区
读缓冲区有数据-＞epoll检测到了会给用户通知
a.用户不读数据，数据一直在缓冲区，epoll会一直通知
b.用户只读了一部分数据，epoll会通知
c.缓冲区的数据读完了，不通知

LT（level - triggered）是缺省的工作方式，并且同时支持block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd 进行IO操作。如果你不作任何操作，内核还是会继续通知你的。
### ET
假设委托内核检测读事件->检测fd的读缓冲区
读缓冲区有数据->epoll检测到了会给用户通知
a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了
b.用户只读了一部分数据，epoll不通知
c.缓冲区的数据读完了，不通知

ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作IO操作（从而导致它再次变成未就绪）。内核不会发送更多的通知（only once)

ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比LT 模式高。epoll
工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死