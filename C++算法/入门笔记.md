把所有的java版本笔记转程c++, 附带跳转到java实现链接
# 一些辅助函数和包
```c++
#include <iostream>  
#include <ctime>  
#include <random>  
using namespace std;

template<class T>  
int length(T &arr){  
    return sizeof(arr)/sizeof(arr[0]);  
}  
  
template<class T>  
void print(T &arr){  
    for(int i=0;i< length(arr);i++){  
        cout<<arr[i]<<" ";  
    }  
}

template<class T>  
void swap(T *arr,int m,int n){  
     T tem= arr[m];  
     arr[m] = arr[n];  
     arr[n] = tem;  
}](<#include %3Ciostream%3E
#include <ctime>
#include <random>

using namespace std;

template<class T>
int length(T &arr){
    return sizeof(arr)/sizeof(arr[0]);
}

template<class T>
void print(T &arr){
    for(int i=0;i< length(arr);i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void print(T &arr,int len){
    for(int i=0;i< len;i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void swap(T *arr,int m,int n){
     T tem= arr[m];
     arr[m] = arr[n];
     arr[n] = tem;
}

int * getRandom(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    int * arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}>)

```
# 二进制运算

转int类型的数变成二进制表示
```c++
void printBinary(int a){  
    int arr[32]={0};  
    int temp;  
    for(int i=0;i<32;i++){  
        temp =a&(1<<(31-i));  
        temp ==0?arr[i]=0:arr[i]=1;  
    }  
  
    print(arr);  
}
```
[[算法笔记新手班#32位运算]]
# 选择、冒泡、插入排序
选择排序一句话：i~n-1范围上，找到最小值并放在i位置，然后i+1~n-1范围上继续


冒泡排序一句话：0~i范围上，相邻位置较大的数滚下去，最大值最终来到i位置，然后0~i-1范围上继续


插入排序一句话：0~i范围上已经有序，新来的数从右到左滑到不再小的位置插入，然后继续

```c++
void selectSort(int *arr,int len){  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        int minIndex=i;  
        for(int j=i+1;j<len;j++){  
            if(arr[j]<arr[minIndex]){  
                minIndex = j;  
            }  
        }  
        swap(arr,minIndex,i);  
    }  
}  
void bubbleSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return ;  
    }  
    for(int i=0;i<len;i++){  
        for(int j=len-1;j>i;j--){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}  
void insertSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        for(int j=i;j<len-1;j++){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}
```
-  [[选择排序]]
- [[冒泡排序]]
-  [[插入排序]]
# 对数器
没啥好写的，具体情况具体分析
生成随机数链接，我们这里采用的是C++11的随机数方案
[生成随机数](https://blog.csdn.net/onion23/article/details/118558454)


# 二分法
## 二分法，找数
注意边界条件时 l <= r
```c++
int binaryExist(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]==num){  
            return mid;  
        }  
        else if(arr[mid]>num){  
            r=mid-1;  
        }  
        else{  
            l=mid+1;  
        }  
    }  
    return -1;  
}
```
- [[在一个有序数组中，找某个数是否存在]]
## 二分法再大于等于or小于等于最左最右
注意要用ans保存之前找到的边界，不然会因为没到结束条件，重新跳一次，然后改变mid值
```c++
int binaryLeft(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    int ans=-1;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]<=num){  
            l= mid+1;  
        }  
        else{  
            ans=mid;  
            r=mid-1;  
        }  
    }  
    return ans;  
}
```

- [[在一个有序数组中，找大于等于某个数最左侧的位置]]
- [[在一个有序数组中，找小于等于某个数最右侧的位置]]

## 寻找峰值
[测试链接](https://leetcode.cn/problems/find-peak-element/)
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。
你可以假设 `nums[-1] = nums[n] = -∞` 。
你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。
**示例 1：**
输入：nums = `[1,2,3,1]`
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
**示例 2：**
输入：nums = `[`1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

- [[局部最小值问题]]
