把所有的java版本笔记转程c++, 附带跳转到java实现链接
# 一些辅助函数和包
```c++
#include <iostream>  
#include <ctime>  
#include <random>  
using namespace std;

template<class T>  
int length(T &arr){  
    return sizeof(arr)/sizeof(arr[0]);  
}  
  
template<class T>  
void print(T &arr){  
    for(int i=0;i< length(arr);i++){  
        cout<<arr[i]<<" ";  
    }  
}

template<class T>  
void swap(T *arr,int m,int n){  
     T tem= arr[m];  
     arr[m] = arr[n];  
     arr[n] = tem;  
}](<#include %3Ciostream%3E
#include <ctime>
#include <random>

using namespace std;

template<class T>
int length(T &arr){
    return sizeof(arr)/sizeof(arr[0]);
}

template<class T>
void print(T &arr){
    for(int i=0;i< length(arr);i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void print(T &arr,int len){
    for(int i=0;i< len;i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void swap(T *arr,int m,int n){
     T tem= arr[m];
     arr[m] = arr[n];
     arr[n] = tem;
}

int * getRandom(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    int * arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}>)](<#include %3Ciostream%3E
#include <ctime>
#include <random>
//#include "vector"
using namespace std;

template<class T>
int length(T &arr){
    return sizeof(arr)/sizeof(arr[0]);
}

template<class T>
void print(T &arr){
    for(int i=0;i< length(arr);i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void print(T &arr,int len){
    for(int i=0;i< len;i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void swap(T *arr,int m,int n){
     T tem= arr[m];
     arr[m] = arr[n];
     arr[n] = tem;
}
int * getRandomArr(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    int * arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}
vector<int> getRandomVector(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    vector<int> vec(n);
    for(int i=0;i<n;i++){
        vec[i]=u(e);
    }
    return vec;

}
template<class T>
vector<T> getRandom(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<T> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    vector<T> arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}

```
# 二进制运算

转int类型的数变成二进制表示
```c++
void printBinary(int a){  
    int arr[32]={0};  
    int temp;  
    for(int i=0;i<32;i++){  
        temp =a&(1<<(31-i));  
        temp ==0?arr[i]=0:arr[i]=1;  
    }  
  
    print(arr);  
}
```
[[算法笔记新手班#32位运算]]
# 选择、冒泡、插入排序
选择排序一句话：i~n-1范围上，找到最小值并放在i位置，然后i+1~n-1范围上继续


冒泡排序一句话：0~i范围上，相邻位置较大的数滚下去，最大值最终来到i位置，然后0~i-1范围上继续


插入排序一句话：0~i范围上已经有序，新来的数从右到左滑到不再小的位置插入，然后继续

```c++
void selectSort(int *arr,int len){  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        int minIndex=i;  
        for(int j=i+1;j<len;j++){  
            if(arr[j]<arr[minIndex]){  
                minIndex = j;  
            }  
        }  
        swap(arr,minIndex,i);  
    }  
}  
void bubbleSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return ;  
    }  
    for(int i=0;i<len;i++){  
        for(int j=len-1;j>i;j--){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}  
void insertSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        for(int j=i;j<len-1;j++){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}
```
-  [[选择排序]]
- [[冒泡排序]]
-  [[插入排序]]
# 对数器
没啥好写的，具体情况具体分析
生成随机数链接，我们这里采用的是C++11的随机数方案
[生成随机数](https://blog.csdn.net/onion23/article/details/118558454)


# 二分法
## 二分法，找数
注意边界条件时 l <= r
```c++
int binaryExist(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]==num){  
            return mid;  
        }  
        else if(arr[mid]>num){  
            r=mid-1;  
        }  
        else{  
            l=mid+1;  
        }  
    }  
    return -1;  
}
```
- [[在一个有序数组中，找某个数是否存在]]
## 二分法再大于等于or小于等于最左最右
注意要用ans保存之前找到的边界，不然会因为没到结束条件，重新跳一次，然后改变mid值
```c++
int binaryLeft(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    int ans=-1;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]<=num){  
            l= mid+1;  
        }  
        else{  
            ans=mid;  
            r=mid-1;  
        }  
    }  
    return ans;  
}
```

- [[在一个有序数组中，找大于等于某个数最左侧的位置]]
- [[在一个有序数组中，找小于等于某个数最右侧的位置]]

## 寻找峰值
[测试链接](https://leetcode.cn/problems/find-peak-element/)
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。
你可以假设 `nums[-1] = nums[n] = -∞` 。
你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。
**示例 1：**
输入：nums = `[1,2,3,1]`
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
**示例 2：**
输入：nums = `[`1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。
***注意保证m！=0，所以l=1.r=len-2 而不是0和n-1。判断逻辑要简化，不然过不了leetcode***
```c++
int findPeakElement(vector<int>& nums) {
// 测试链接 : https://leetcode.cn/problems/find-peak-element/
    int len = nums.size();
    if(len==1){return 0;}
    if(nums[1]<nums[0]){return 0;}
    if(nums[len-1]>nums[len-2]){return len-1;}
    int l =1;
    int r =len-2;
    int m =0;
    while(l<=r){
        m = (l+r)/2;
        if (nums[m - 1] > nums[m]) {
            r = m - 1;
        } else if (nums[m] < nums[m + 1]) {
            l = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```

- [[局部最小值问题]]

# 链表

## 链表反转
 [[04 单链表跟双链表]]   
 经典题目: [[单链表和双链表如何反转]]  
 
### 单链表
 数据结构在测试链接里
 ```c++
 // 反转单链表测试链接 : https://leetcode.cn/problems/reverse-linked-list/
 ListNode* reverseList(ListNode* head) {  
    ListNode *pre= nullptr;  
    ListNode *next= nullptr;  
    while (head!= nullptr){  
        next = head->next;  
        head->next =pre;  
        pre =head;  
        head = next;  
    }  
    return pre;  
}
```
### 双链表
懒了，没有数据结构，一样的，看java代码吧
## 合并有序链表
21.[[两个有序链表的合并]]   [E]

