把所有的java版本笔记转程c++, 附带跳转到java实现链接
# 一些辅助函数和包
```c++
#include <iostream>  
#include <ctime>  
#include <random>  
using namespace std;

template<class T>  
int length(T &arr){  
    return sizeof(arr)/sizeof(arr[0]);  
}  
  
template<class T>  
void print(T &arr){  
    for(int i=0;i< length(arr);i++){  
        cout<<arr[i]<<" ";  
    }  
}

template<class T>  
void swap(T *arr,int m,int n){  
     T tem= arr[m];  
     arr[m] = arr[n];  
     arr[n] = tem;  
}](<#include %3Ciostream%3E
#include <ctime>
#include <random>

using namespace std;

template<class T>
int length(T &arr){
    return sizeof(arr)/sizeof(arr[0]);
}

template<class T>
void print(T &arr){
    for(int i=0;i< length(arr);i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void print(T &arr,int len){
    for(int i=0;i< len;i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void swap(T *arr,int m,int n){
     T tem= arr[m];
     arr[m] = arr[n];
     arr[n] = tem;
}

int * getRandom(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    int * arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}>)](<#include %3Ciostream%3E
#include <ctime>
#include <random>
//#include "vector"
using namespace std;

template<class T>
int length(T &arr){
    return sizeof(arr)/sizeof(arr[0]);
}

template<class T>
void print(T &arr){
    for(int i=0;i< length(arr);i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void print(T &arr,int len){
    for(int i=0;i< len;i++){
        cout<<arr[i]<<" ";
    }
}
template<class T>
void swap(T *arr,int m,int n){
     T tem= arr[m];
     arr[m] = arr[n];
     arr[n] = tem;
}
int * getRandomArr(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    int * arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}
vector<int> getRandomVector(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<int> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    vector<int> vec(n);
    for(int i=0;i<n;i++){
        vec[i]=u(e);
    }
    return vec;

}
template<class T>
vector<T> getRandom(int n){
    std::default_random_engine e;
    std::uniform_int_distribution<T> u(2,20); // 左闭右闭区间
    e.seed(time(0));

    vector<T> arr = new int [n];
    for(int i=0;i<n;i++){
        arr[i]=u(e);
    }
    return arr;
}

void printList(ListNode* head) {  
    ListNode* current = head;  
    while (current != nullptr) { // 当节点不为空时  
        cout << current->val << " "; // 打印节点的值  
        current = current->next; // 移动到下一个节点  
    }  
    cout << endl; // 换行  
}

```
# 二进制运算

转int类型的数变成二进制表示
```c++
void printBinary(int a){  
    int arr[32]={0};  
    int temp;  
    for(int i=0;i<32;i++){  
        temp =a&(1<<(31-i));  
        temp ==0?arr[i]=0:arr[i]=1;  
    }  
  
    print(arr);  
}
```
[[算法笔记新手班#32位运算]]
# 选择、冒泡、插入排序
选择排序一句话：i~n-1范围上，找到最小值并放在i位置，然后i+1~n-1范围上继续


冒泡排序一句话：0~i范围上，相邻位置较大的数滚下去，最大值最终来到i位置，然后0~i-1范围上继续


插入排序一句话：0~i范围上已经有序，新来的数从右到左滑到不再小的位置插入，然后继续

```c++
void selectSort(int *arr,int len){  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        int minIndex=i;  
        for(int j=i+1;j<len;j++){  
            if(arr[j]<arr[minIndex]){  
                minIndex = j;  
            }  
        }  
        swap(arr,minIndex,i);  
    }  
}  
void bubbleSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return ;  
    }  
    for(int i=0;i<len;i++){  
        for(int j=len-1;j>i;j--){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}  
void insertSort(int *arr,int len){  
  
    if (arr == nullptr || len < 2) {  
        return;  
    }  
    for(int i=0;i<len-1;i++){  
        for(int j=i;j<len-1;j++){  
            if (arr[j]<arr[j-1]){  
                swap(arr,j,j-1);  
            }  
        }  
    }  
}
```
-  [[选择排序]]
- [[冒泡排序]]
-  [[插入排序]]
# 对数器
没啥好写的，具体情况具体分析
生成随机数链接，我们这里采用的是C++11的随机数方案
[生成随机数](https://blog.csdn.net/onion23/article/details/118558454)


# 二分法
## 二分法，找数
注意边界条件时 l <= r
```c++
int binaryExist(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]==num){  
            return mid;  
        }  
        else if(arr[mid]>num){  
            r=mid-1;  
        }  
        else{  
            l=mid+1;  
        }  
    }  
    return -1;  
}
```
- [[在一个有序数组中，找某个数是否存在]]
## 二分法再大于等于or小于等于最左最右
注意要用ans保存之前找到的边界，不然会因为没到结束条件，重新跳一次，然后改变mid值
```c++
int binaryLeft(int *arr, int num, int len){  
    if (arr == nullptr||len<=0) {  
        return -1;  
    }  
    int l =0;  
    int r =len-1;  
    int mid =0;  
    int ans=-1;  
    while (l<=r){  
        mid =l+(r-l)/2;  
        if(arr[mid]<=num){  
            l= mid+1;  
        }  
        else{  
            ans=mid;  
            r=mid-1;  
        }  
    }  
    return ans;  
}
```

- [[在一个有序数组中，找大于等于某个数最左侧的位置]]
- [[在一个有序数组中，找小于等于某个数最右侧的位置]]

## 寻找峰值
[测试链接](https://leetcode.cn/problems/find-peak-element/)
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。
你可以假设 `nums[-1] = nums[n] = -∞` 。
你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。
**示例 1：**
输入：nums = `[1,2,3,1]`
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
**示例 2：**
输入：nums = `[`1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5， 其峰值元素为 6。
***注意保证m！=0，所以l=1.r=len-2 而不是0和n-1。判断逻辑要简化，不然过不了leetcode***
```c++
int findPeakElement(vector<int>& nums) {
// 测试链接 : https://leetcode.cn/problems/find-peak-element/
    int len = nums.size();
    if(len==1){return 0;}
    if(nums[1]<nums[0]){return 0;}
    if(nums[len-1]>nums[len-2]){return len-1;}
    int l =1;
    int r =len-2;
    int m =0;
    while(l<=r){
        m = (l+r)/2;
        if (nums[m - 1] > nums[m]) {
            r = m - 1;
        } else if (nums[m] < nums[m + 1]) {
            l = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```

- [[局部最小值问题]]

# 链表

## 链表反转
 [[04 单链表跟双链表]]   
 经典题目: [[单链表和双链表如何反转]]  
 
### 单链表
 数据结构在测试链接里
 ```c++
 // 反转单链表测试链接 : https://leetcode.cn/problems/reverse-linked-list/
 ListNode* reverseList(ListNode* head) {  
    ListNode *pre= nullptr;  
    ListNode *next= nullptr;  
    while (head!= nullptr){  
        next = head->next;  
        head->next =pre;  
        pre =head;  
        head = next;  
    }  
    return pre;  
}
```
### 双链表
懒了，没有数据结构，一样的，看java代码吧
## 合并有序链表
21.[[两个有序链表的合并]]   [E]
===经典错误答案===
虽然list变了，但是head并没有变，head一直指向的是list1/list2的头节点
```c++

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  
    if (list1== nullptr) {return list2;}  
    if (list2 == nullptr){return list1;}  
    ListNode *list= nullptr;  
    if (list1->val<list2->val){  
        list =list1;  
        list1 =list1->next;  
    }  
    else{  
        list= list2;  
        list2 =list2->next;  
    }  
    ListNode *head= list;  
    list =list->next;  
    while (list1!= nullptr&&list2!= nullptr){  
        if (list1->val<list2->val){  
            list =list1;  
            list1 =list1->next;  
        }  
        else{  
            list= list2;  
            list2 =list2->next;  
        }  
        list = list->next;  
    }  
    if (list1== nullptr) {list=list2;}  
    if (list2 == nullptr){list=list1;}  
    return  head;  
}
```
改正
要改变的是list-next的值，只有这样head指向的地址才会不断加长，不断改变，===用next把他们穿起来===

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  
    if (list1== nullptr) {return list2;}  
    if (list2 == nullptr){return list1;}  
    ListNode *list= nullptr;  
    if (list1->val<list2->val){  
        list =list1;  
        list1 =list1->next;  
    }  
    else{  
        list= list2;  
        list2 =list2->next;  
    }  
    ListNode *head= list;  
    while (list1!= nullptr&&list2!= nullptr){  
        if (list1->val<list2->val){  
            list->next =list1;  
            list1 =list1->next;  
        }  
        else{  
            list->next= list2;  
            list2 =list2->next;  
        }  
        list = list->next;  
    }  
    if (list1== nullptr) {list->next=list2;}  
    if (list2 == nullptr){list->next=list1;}  
    return  head;  
}
```

## 两个链表相加
给你两个 非空 的链表，表示两个非负的整数
它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头
[测试链接](https://leetcode.cn/problems/add-two-numbers)
[[两个链表相加]] 
```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
    if (l1== nullptr) {return l2;}  
    if (l2 == nullptr){return l1;}  
    int carry =0;  
    ListNode *list = new ListNode((l1->val+l2->val+carry)%10);  
    carry = (l1->val+l2->val+carry)/10;  
    l1=l1->next;  
    l2=l2->next;  
    ListNode *head =list;  
    while (l1!= nullptr&&l2!= nullptr){  
        list->next = new ListNode((l1->val+l2->val+carry)%10);  
        carry = (l1->val+l2->val+carry)/10;  
        l1=l1->next;  
        l2=l2->next;  
        list=list->next;  
    }  
    if(l1== nullptr&&l2== nullptr){  
        if(carry){list->next = new ListNode(carry);}  
    }  
    else if (l1== nullptr) {  
        while (l2!= nullptr) {  
            list->next = new ListNode((carry + l2->val) % 10);  
            carry = (carry+ l2->val) / 10;  
            l2 = l2->next;  
            list = list->next;  
        }  
        if(carry){list->next = new ListNode(carry);}  
  
    }  
    else if (l2 == nullptr){  
        while (l1!= nullptr) {  
            list->next = new ListNode((carry + l1->val) % 10);  
            carry = (carry+ l1->val) / 10;  
            l1 = l1->next;  
            list = list->next;  
        }  
        if(carry){list->next = new ListNode(carry);}  
    }  
    return head;  
}
```

## 划分链表
[题目链接](https://leetcode.cn/problems/partition-list/)
[[将单向链表按某值划分成左边小、中间相等、右边大的形式]]  
注意节点要断连，不然会造成节点环
注意边界条件，全都是一边要怎么办。用next指针的时候要确保非空
```c++
ListNode* partition(ListNode* head, int x) {  
    ListNode *list1 = nullptr;  
    ListNode *list2 = nullptr;  
    ListNode *head1 = nullptr;  
    ListNode *head2 = nullptr;  
    if (head== nullptr){return head;}  
    while (head!= nullptr){  
        if(head->val<x){  
            if (list1== nullptr){  
                list1 = head;  
                head1 = list1;  
                head =head->next;  
                list1->next= nullptr;  
            }  
            else{  
                list1->next = head;  
                head = head->next;  
                list1 = list1->next;  
                list1->next= nullptr;  
  
            }  
        }  
        else{  
            if (list2== nullptr){  
                list2 = head;  
                head2 = list2;  
                head =head->next;  
                list2->next= nullptr;  
            }  
            else{  
                list2->next = head;  
                head = head->next;  
                list2 = list2->next;  
                list2->next= nullptr;  
            }  
        }  
    }  
    if (list1!= nullptr){  
        list1->next =head2;  
        return head1;  
    }  
    else{  
        return  head2;  
    }  
}
```





# 栈和队列
## 栈和队列（循环队列）的实现
 [[双向链表实现栈和队列]]  
 [[数组实现栈和队列]]  
 我只用c++写了数组实现
```c++
class Queue{  
public:  
    Queue(int Capacity){  
        this->Capacity=Capacity;  
        this->arr = new int [Capacity];  
        this->L=0;  
        this->R=0;  
    }  
    bool push(int x){  
        if(R<Capacity){  
            arr[R]=x;  
            ++R;  
            return true;  
        }  
        else{  
            return false;  
        }  
    }  
    bool  pop(){  
        if(R>0){  
            ++L;  
            return true;  
        } else{  
            return false;  
        }  
    }  
    int peek() {  
        if (L>0){  
            return arr[L];  
        }  
        else{  
            return -1;  
        }  
    }  
  
    bool empty() {  
        return R<=0;  
    }  
private:  
    int Capacity;  
    int Size;  
    int * arr;  
    int L;  
    int R;  
};  
  
  
class Stack{  
public:  
    Stack(int Capacity){  
        this->Capacity=Capacity;  
        this->arr = new int [Capacity];  
        this->R=0;  
    }  
    bool push(int x){  
        if(R<Capacity){  
            arr[R]=x;  
            ++R;  
            return true;  
        }  
        else{  
            return false;  
        }  
    }  
    bool  pop(){  
        if(R>0){  
            --R;  
            return true;  
        } else{  
            return false;  
        }  
    }  
    int peek() {  
        if (R>0){  
            return arr[R-1];  
        }  
        else{  
            return -1;  
        }  
    }  
  
    bool empty() {  
        return R<=0;  
    }  
private:  
    int Capacity;  
    int * arr;  
    int R;  
};
    }```
### 循环队列
 [测试链接](https://leetcode.cn/problems/design-circular-queue/)
 [[数组实现栈和队列#数组实现循环队列]]  
```c++
class MyCircularQueue {  
public:  
    MyCircularQueue(int k) {  
        this->Capacity= k;  
        this->arr = new int [k];  
        this->Size=0;  
        this->L=0;  
        this->R=0;  
    }  
  
    bool enQueue(int value) {  
        if (Size<Capacity){  
            arr[R]=value;  
            R=(R+1)%Capacity;  
            Size++;  
            return true;  
        }  
        return false;  
    }  
  
    bool deQueue() {  
        if (Size>0){  
            L=(L+1)%Capacity;  
            Size--;  
            return true;  
        }  
        return false;  
    }  
  
    int Front() {  
        if(!isEmpty()){return arr[L];}  
        return -1;  
    }  
  
    int Rear() {  
        if(!isEmpty()){  
            int last=R==0?(Capacity-1):(R-1);  
            return arr[last];  
        }  
        return -1;  
    }  
  
    bool isEmpty() {  
        return Size<=0;  
    }  
  
    bool isFull() {  
        return Size==Capacity;  
    }  
private:  
    int Capacity;  
    int Size;  
    int * arr;  
    int L;  
    int R;  
};
```
## 栈和队列的相互实现
[用栈实现队列测试链接](https://leetcode.cn/problems/implement-queue-using-stacks/)
老师的思路更好：
	倒数据  
	从in栈，把数据倒入out栈  
	 1) out空了，才能倒数据  
	2) 如果倒数据，in必须倒完
我的不行，就直接倒了
```c++
class MyQueue {
public:
    MyQueue() {

    }

    void push(int x) {
        stackin.push(x);
    }

    int pop() {
        while (!stackin.empty()){
            stackout.push(stackin.top());
            stackin.pop();
        }
        int a =stackout.top();
        stackout.pop();

        while (!stackout.empty()){
            stackin.push(stackout.top());
            stackout.pop();
        }
        return a;
    }

    int peek() {
        while (!stackin.empty()){
            stackout.push(stackin.top());
            stackin.pop();
        }
        int a =stackout.top();
        while (!stackout.empty()){
            stackin.push(stackout.top());
            stackout.pop();
        }
        return a;
    }

    bool empty() {
        return stackin.empty();
    }
private:
    std::stack%3Cint%3E stackin;
    std::stack<int> stackout;
};
```

[[如何用栈结构实现队列结构]]  
[[如何用队列结构实现栈结构]]  

## 最小栈
[测试链接](https://leetcode.cn/problems/min-stack/)
``` c++
class MinStack {  
public:  
    MinStack() {  
        data = new Stack(10000);  
        min = new Stack(10000);  
    }  
  
    void push(int val) {  
        data->push(val);  
        if (min->empty()){  
            min->push(val);  
        }  
        else if(min->peek()>val){  
            min->push(val);  
        }  
        else{  
            min->push(min->peek());  
        }  
    }  
  
    void pop() {  
        data->pop();  
        min->pop();  
    }  
  
    int top() {  
        return data->peek();  
    }  
  
    int getMin() {  
        return min->peek();  
    }  
private:  
    Stack* data;  
    Stack* min;  
};
```
[[实现最小栈]]  

## 双端队列
