# 基数排序的没有桶的优化版本-难点解释

---

1. 准备等长help数组跟 长度为10的count数组
2. 先根据每个数个位统计有几个数记在count数组中
3. 根据count数组加工出前缀和count'数组, 代表个位数字<=index的数一共有几个
4. 从右往左遍历数组, 考察每个数个位上的数, 查表count'数组找到应该去的位置, 填到help数组里, 同时count'数组对应index--
5. 按照2~4步骤依次处理高位


这个方法就省掉了很多桶，你只用一个长度为十的count数组，再用一个长度跟原来array一样的辅助数组, 
入桶出桶就完事了，你不用去准备十个队列，你可以真的用十个队去完成这件事，但没这个优雅

### 初始状态, 生成Count, 前缀和Count\`, 以及help数组

![[Pasted image 20201207223959.png]]


### 从左往右遍历数组, 先看第一个数字040:

![[Pasted image 20201207230538.png]]

Count\`数组中, 0位置的1被使用过了, 自减1, 变为0


### 倒数第二个数031
![[Pasted image 20201207230829.png]]
Count\`数组中, 1位置的4被使用过了, 自减1, 变为3

### 倒数第三个数022

![[Pasted image 20201207231207.png]]

Count\`数组中, 2位置的5被使用过了, 自减1, 变为4

### 倒数第四个数001

![[Pasted image 20201207231602.png]]
Count\`数组中, 1位置的3被使用过了, 自减1, 变为2


### 倒数第五个数101

![[Pasted image 20201207233326.png]]

Count\`数组中, 1位置的2被使用过了, 自减1, 变为1


用这种方式没有桶, 优雅的实现了出桶入桶

只更新当前数字的count\`数组, 因为我只关心我当前数字的出现范围, 当填过以后, 当前数字的范围就会缩小


## 难点
数组中的数, 如果入桶, 越在后面的数, 越在桶的后面, 出桶最晚, 拍的位置比同一个桶内前面的数靠后

![[Pasted image 20201207232747.png]]

遍历数组, 从右往左, 则 当前数就是桶内最后一个数, 应该放在count\`数组确定的数组范围的最后/右一个

### 从右往左填数的顺序解释

![[Pasted image 20201208004207.png]]

Count\`数组中, 1位置的4被使用过了, 自减1, 变为3
![[Pasted image 20201208004216.png]]


为什么从右往左遍历==>
因为思路就是 每一个个位数出现的数字就是从右往左填写

### 如果从左往右填写呢?
当然, 也可以从左往右遍历, ==需要就算>=1的数有几个==, 就可以推出一个范围 i ~N-1, 顺着填写, Count\`前缀和数组倒着生成即可

![[Pasted image 20201208004753.png]]




