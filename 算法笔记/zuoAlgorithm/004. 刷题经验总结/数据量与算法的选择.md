# 数据量与算法的选择

由数据范围反推算法复杂度

---
1s 能解决的数据规模在: 10^6~10^7

- O(N^2)的算法:  10^3~10^4
- O(N)的算法:  10^7~10^8
- O(NlogN)的算法:  10^6~10^7

| |数据规模|时间复杂度|算法举例|
|--     |--      |--  |--|
|1|10|O(N!)| 全排列|
|2|20~30|O(2^N)| 排列组合, 分治|
|3|50|O(N^4)| DFS, DP|
|4|100|O(N^3)| 任意两点最短路径, DP|
|5|1000|O(N^2)| 稠密图, DP|
|6|10^6|O(NlogN)| 排序, 堆, 递归与分治|
|7|10^7|O(N)| DP, 图遍历, 拓扑排序, 树遍历|
|8|10^9|O(√N)| 线性筛素数, 求平方根|
|9|10^10|O(logN)| 二分搜索|
|10|+∞|O(1)| 数学相关算法|

https://www.acwing.com/blog/content/32/


一般ACM或者笔试题的C++时间限制是1~2秒, Java/Python等脚本语言为2~4秒。
在这种情况下，代码中的操作次数控制在 10^7∼10^8为最佳。

下面给出在不同数据范围下、代码的时间复杂度和算法该如何选择:

1.  n <= 30: 指数级别、dfs+剪枝、状态压缩dp、 分治(数值巨大, 分成2^15的两部分)

2.  n <= 100 => O(n^3): Floyd、dp、高斯消元

3.  n <= 1000 => O(n^2)、O(n^2logn): dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford

4.  n <=10^4 => O(n\*√n): 块状链表、分块、莫队

5.  n <=10^5 =>O(nlogn): 各种sort、线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、 prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树

6.  n <=10^6 => O(n), 以及常数较小的O(nlogn)算法: 
   单调队列、hash、双指针扫描、并查集、KMP、AC自动机
   常数比较小的O(nlogn)的做法: sort、树状数组、heap、dijkstra、spfa 

7. n<=10^7 => O(n): 双指针扫描、KMP、AC自动机、线性筛素数

8.  n<=10^9 => O(√n): 判断质数

9.  n<=10^18 => O(logN): 最大公约数、快速幂、数位DP

10.  n<=10^1000 => O((logn)^2): 高精度加减乘除

11.  n<=10^100000 => O(logk\*loglogk), k表示位数: 高精度加减、FFT/NTT


[[时间复杂度]]

