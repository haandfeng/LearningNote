# 窗口的三种类型总结

---

窗口问题的三种模型  
类型1:  一个数组中, 一个L..R从左往右的窗口, R往右一个数进窗口, L往右一个数出窗口    
类型2: 一个数组中, L, R从两边想中间移动   
类型3: 一个数组中, L,R从中间先两边移动  


## 窗口敏感度怎么去想?

第一个技巧(题目一给我们的启示):  
当有一个问题它描述的指标是S，有可能是累加和问题也有可能是别的问题，你就看看范围  
变化了这个指标有没有单调性。当然它跟实际的数据状况比如全是正数，全是非负这种东西  
有关, 它也和你问的标准有关，但总而言之是你看看范围变化，它有没有单调性，如果有的话, 往窗口这想。


第二个技巧:  
利用预处理结构的优化。我记录一个最早前缀和出现的位置能搞定遍历的问题。就不用再遍历的找了,  
我每次从这个最前缀和最早出现的位置直接定位答案。同时还有一点就是子数组问题，甭管问的是什么，  
你就把答案定成必须以 0 结尾的时候怎么样，必须以 1 结尾的时候怎么样，必须以 2 结尾的时候怎么样，  
或者必须以 0 开头怎么样？以1开头怎么样？以 2 开头怎么样？你就这么去套，憋你也给他憋出来

第三个技巧:  
假设答案法+淘汰可能性  
淘汰可能性一旦哪个题目出现了，很难, 因为它挑战了一种想法，它把我每个位置求一个答案, 最后答案一定在其中的想法颠覆掉了。  
我可能每一个位置求不出它正确的答案。我就要看我求出一个更短的，或者具体这个问题，我们要求的是小于等于 K 的最长问题,  
所以我们精确求解每一个开头时的答案是否必要就变得不必要了。我只关注能够把最终答案推高的可能性。淘汰掉每一次都求正确  
答案的所有的情况, 只关注能不能变更大的可能性。比如Max Gap(无序数组如果排序之后相邻数之间的最大差值)问题.  
技巧三一时之间很难掌握硬背这个题。技巧一跟技巧二好好想一想都是可以推广出去的。比如说你利用预处理结构，比如前缀和数  
组，线段树， index Tree，都算预数据结构，你想得到累加和都很方便了，还能支持单点更新，我们讲了很多预处理结构了这不新鲜。