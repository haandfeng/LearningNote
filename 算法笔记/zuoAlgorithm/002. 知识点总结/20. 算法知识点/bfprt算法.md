# bfprt算法

#bfprt 

---

> BFPRT算法：从n个元素中选出第k小或第k大的元素，同时也能选出前k小或前k大的所有元素。
> BFPRT算法有点类似于快速排序算法，快速排序每一趟Partion的过程中一般都是选择第1个元素作为pivot，将小于pivot的元素交换到左边，将大于pivot的元素交换到右边，然后将pivot插入到它们的中间，最终得到的序列——pivot左边的元素都小于等于pivot，pivot右边的元素都大于等于pivot。BFPRT在Partion的过程中与快速排序不同的是它不是选择第1个元素作为pivot，而是对序列递归求取中位数，以该中位数作为pivot对序列进行划分。
> 时间复杂度：最坏情况的时间复杂度是O(n)


## 大流程
1) 五个数一组, 因为只是个逻辑概念, 复杂度O(1)  
2) 每一个小组内的五个数排序，所有小组都干一遍 O(N)  
3) 把每一个小组里面的一个中位数拿出来组成 M 数组, O(N)  
4) 递归调用bfprt, 传入M数组, 求中位数P 如果整个表达式是T(N), 这一步是T(N/5)  
5) 拿这个特殊选出来的P做荷兰国旗问题, O(N)  
6) 如果命中了就停止，如果没命中，**即便是最差的情况，你也只用承担一个十分之七 N 的代价**  


算法导论证明了, 时间复杂度O(N)
不能使用Master公式, 因为子过程的规模不一样


笔试时候不要写bfprt算法, 常数项有点高
面试时候做了经典解法, 讲bfprt加分

- [[bfprt代码]]