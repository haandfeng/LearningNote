# 分治

---

1，数据量整体做尝试可能性太多了，跑不完   
2，数据分成多个块（常见是两块）之后，各自的可能性并不算多   
3，合并多个块各自信息的整合过程不复杂   

10^8的瓶颈:  
如果C或C++给你一秒钟或者其它语言给你2~4秒，你知道自己10^8一定要控制在这个范围内，否则这些code肯定会超时，  
这是一个大限制，于是我们就我们就在众多可以脑补的方案中有了一条主线，10^8的指令集不能超过他，  
我们就可以根据输入数据的状况，启发自己从什么角度想，或者自己想了一个办法看看，如果超过了10^8就直接杀死，  
这里面就要求你具备一定的方法多样性了，所以我给你补了一个技巧就是分治

### 什么时候用分治?  
**样本量不大**，比如 arr 长度比较少的时候，你很自然就想长度很少，**但也没有少到全暴力展开在10^8以内, 分治**, 
极大的提醒。分治的前提是我把较长的长度切成左右两半，左部分会在10^8以内告诉我答案, 右部分会在10^8
以内告诉我答案，而且**整合的逻辑不太复杂**。

## 分治的应用场景
剩下所有的值都特别大, 除了arr的这个长度它不大，但是整个玩暴力递归又拿不下，
是不是坚定了你去搞它整合逻辑的信心。有的时候你写不出来，是你觉得你写不出来，
我告诉你一定能写出来，你就憋。

往往是当我数据量的总体个数没有太夸张，但是你直接不切成左两半硬去搞每一个位置, 每个位置两个分支，  
每个位置两个分支的话会超时，那我就很自然的想，我就把我左侧砍一半它去跑暴力，右侧砍一半它去跑暴力，  
如果整个是30的长度，2^30很大，但是2^15+2^15没多大，这样一来我就可以单独拿下左侧的暴力和右侧的暴力，  
不会超时，接下来我只要去硬憋左右两侧的整合逻辑，这事儿就搞定了。


## 题目
[[非负数组子序列中累加和%m的最大值]]  
[[背包中有多少种零食放法]]  
1755.[[最接近目标值的子序列和]]  [H]
